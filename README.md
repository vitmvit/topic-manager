# topic-manager

### Задача

Разработайте систему управления топиками, которая позволит:

1. Создавать топики (топик состоит из названия и сообщений)
2. Публиковать сообщения в топики.
3. Обрабатывать сообщения от топиков с использованием блокировок и условий.
4. Потребители должны извлекать сообщения по одному и засыпать при отсутствии новых сообщений, просыпаться, когда
   появится новое сообщение.
5. Сообщения должны сохраняться в списке сообщений, чтобы каждый потребитель мог читать те же сообщения.
6. Для каждого потребителя должен быть механизм сохранения индекса последнего вычитанного сообщения.
7. Для потребителя добавить возможность, передавать CountDownLatch (для ограничения кол-ва читаемых сообщений) и
   коллекцию для сохранения прочитанных сообщений.
8. Написать тесты.
9. Реализовать механизм единовременного доступа к топику(что бы мы могли задать максимальное кол-во потребителей,
   которые могут читать сообщение из одного и того же топика)

### Реализация

1. Создание топика
    1. Создание объекта топика

       В классе TopicManager, создается новый объект типа Topic с заданным именем и максимальным количеством
       потребителей. Например:

        ```Java
        Topic topic = new Topic("MyTopic", 3);
        ```

       Здесь "MyTopic" — это имя топика, а 3 — максимальное число потребителей, которые могут одновременно читать
       сообщения
       из этого топика.
    2. Публикация сообщений

       Созданный топик принимает сообщения от производителей через метод publishMessage, который добавляет новое
       сообщение в список сообщений и уведомляет всех ожидающих потребителей.

    3. Потребление сообщений:
       Потребители могут извлекать сообщения из созданного топика, и когда они заканчивают работу, они используются для
       получения сообщений, пока не достигнут ограничения, заданного с помощью CountDownLatch.

2. Публикация и обработка сообщений
    1. Создание сообщения
       Внутри метода publishMessage создается новый объект Message, который содержит текст сообщения. Это происходит с
       помощью вызова конструктора Message:
       ```java
       Message message = new Message(messageContent);
       ```
    2. Добавление сообщения в список
       Созданное сообщение добавляется в список messages, который хранит все сообщения топика:
       ```java
       messages.add(message);
       ```
    3. Вывод информации
       В консоль выводится сообщение о том, что доступное новое сообщение было опубликовано:
       ```java
       System.out.println("publish message: " + messageContent);
       ```
    4. Уведомление потребителей
       После добавления сообщения в список вызывается метод signalAll() на условии newMessageCondition. Это уведомляет
       всех потребителей, которые могут ожидать сообщения в методе consumeMessage, что новое сообщение доступно для
       чтения:
       ```java
       newMessageCondition.signalAll(); // Разбудить всех ожидающих потребителей
       ```
    5. Вызов метода publishMessage
       Когда производитель хочет опубликовать сообщение, он вызывает метод publishMessage(), передавая ему содержимое
       сообщения. Процесс публикации включает создание объекта Message, добавление его в список сообщений (который
       хранится в классе Topic), вывод информации о публикации и уведомление ожидающих потребителей. Фрагмент
       кода из класса Producer:
       ```java
        @Override
        public void run() {
            for (String messageContent : messageList) {
                topic.publishMessage(messageContent);
                System.out.println("publish message: " + messageContent);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        ```
       В этом методе run производителя сообщения публикуются в топике через вызов topic.publishMessage(...) в цикле.
    6. Ожидание сообщений (Consumer)
       Ожидание новых сообщений: В классе Consumer реализуется метод consumeMessage, который ожидает, пока новые
       сообщения появятся в топике. Он использует условие newMessageCondition для ожидания.

    7. Чтение сообщении (Consumer)
       После того как новое сообщение становится доступным, метод consumeMessage возвращает это сообщение потребителю,
       который может затем его обработать.
       Пример обработки сообщения в методе run класса Consumer:
       ```java
        @Override
        public void run() {
            try {
                while (latch.getCount() > 0) {
                    Message message = topic.consumeMessage(this, lastReadIndex);
                    if (message != null) {
                        messageList.add(message);
                        lastReadIndex++;
                        latch.countDown();
                        System.out.println("thread: " + Thread.currentThread().getName() + "; message: " + message.getContent() + "; messageList size: " + messageList.size());
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
       ```
    8. Пример полного механизма

        - Создается объект Topic.
        - Создается и запускается экземпляр Producer.
        - Создаются и запускаются несколько экземпляров Consumer.
        - Производитель публикует 5 сообщений в топик, каждое с 1-секундной задержкой.
        - Потребители, ожидая сообщения, будут уведомлены и смогут прочитать сообщения, когда они будут опубликованы.

3. Извлечение сообщений по одному и сон при отсутствии новых сообщений

    1. Синхронизация с использованием Lock и Condition:

        - Используется ReentrantLock для обеспечения потокобезопасного доступа к списку сообщений и управления
          потребителями.
        - Condition newMessageCondition используется для ожидания новых сообщений. Это позволяет потребителям «уснуть»,
          когда сообщений нет, и «проснуться», когда производитель публикует новое сообщение.

    2. Метод consumeMessage(Consumer consumer):
        - Когда потребитель пытается извлечь сообщение, он первым делом блокирует доступ к общему ресурсу (списку
          сообщений) с помощью lock.lock().
        - Затем проверяется, есть ли сообщения в списке (вызовом messages.isEmpty()):
        - Если сообщений нет, потребитель входит в состояние ожидания с помощью newMessageCondition.await(). Этот вызов
          заставляет поток ждать до тех пор, пока не будет вызван сигнал для пробуждения (в данном случае — когда
          производитель публикует новое сообщение).
        - Когда новое сообщение публикуется (вызовом publishMessage), newMessageCondition.signalAll() сигнализирует всем
          ожидающим потокам, что новое сообщение доступно.

    3. Извлечение сообщения:
        - Как только есть доступные сообщения, метод удаляет первое сообщение из списка и возвращает его.
        - После этого потребитель удаляется из списка потребителей, что гарантирует, что его состояние больше не будет
          участвовать в логике обработки сообщений.

    4. Пример полного механизма
        - Потребитель запускает цикл, пока остается неполученное количество сообщений (while (latch.getCount() > 0)).
        - Вызовом topic.consumeMessage(this) он пытается извлечь сообщение. Если сообщений нет, он "уснет" до тех пор,
          пока новое сообщение не будет опубликовано.
        - Когда сообщение успешно извлечено, оно добавляется в список прочитанных сообщений, и потребитель уменьшает
          счетчик потраченных сообщений (latch.countDown()).

4. Cохранения индекса последнего прочитанного сообщения

   Механизм сохранения индекса последнего прочитанного сообщения реализован в классе Consumer с помощью переменной
   lastReadIndex
    1. Переменная lastReadIndex
        - Инициализируется значением -1, что означает, что потребитель еще не прочитал ни одно сообщение. Каждый раз,
          когда потребитель успешно извлекает новое сообщение, этот индекс увеличивается на 1. Это позволяет знать,
          сколько сообщений было извлечено.

    2. Увеличение индекса:
        - Когда новое сообщение успешно получено вызовом topic.consumeMessage(this), перед тем как снизить счетчик
          latch, значение lastReadIndex увеличивается (lastReadIndex++).
        - Это действие позволяет хранить информацию о том, какое по счету сообщение было последним прочитанным, что
          может быть полезно для реализации функциональности, связанной с контролем состояния потребителей (например,
          для рестарта или возобновления чтения после сбоя).

5. CountDownLatch

   Механизм передачи CountDownLatch и коллекции для сохранения прочитанных сообщений реализован через конструктор класса
   Consumer
    1. Параметры конструктора:
        - При создании объекта Consumer ожидается передача необходимых параметров:
        - Topic topic: топик, из которого потребитель будет извлекать сообщения.
        - CountDownLatch latch: экземпляр CountDownLatch, который будет использоваться для ограничения числа сообщений,
          которые может прочитать данный потребитель.
        - List<Message> readMessages: коллекция (например, ArrayList), в которую будут сохраняться все прочитанные
          сообщения.

    2. Использование CountDownLatch:
        - Этот механизм управления потоками позволяет уменьшить счетчик (latch.countDown()) каждый раз, когда
          потребитель успешно прочитывает сообщение.
        - Как только значение счетчика достигает нуля, это может сигнализировать основному потоку (или любому другому
          слушателю), что все сообщения были прочитаны, что может быть полезно для контроля завершения работы.

    3. Сохранение прочитанных сообщений:
        - Каждый раз, когда потребитель читает сообщение, оно добавляется в коллекцию readMessages (readMessages.add(
          message)). Это позволяет сохранять все полученные сообщения в одну структуру данных, доступную для последующей
          обработки или анализа.

    4. Пример полного механизма
       Пример того, как можно создать объект Consumer, передав ему CountDownLatch и коллекцию для хранения прочитанных
       сообщений:
       ```java
        CountDownLatch latch = new CountDownLatch(numberOfMessagesToRead);
        List<Message> readMessages = new ArrayList<>();
        Consumer consumer = new Consumer(topic, latch, readMessages);
        new Thread(consumer).start();
       ```

6. Механизм единовременного доступа к топику
    1. Объявление и инициализация семафора:
       В классе Topic добавлен объект семафора.
       ```java
        private final Semaphore semaphore;
       
        public Topic(String name, int maxConsumers) {
            this.name = name;
            this.semaphore = new Semaphore(maxConsumers);
        }   
       ```
       Здесь maxConsumers — это максимальное количество потоков-потребителей, которые могут одновременно читать
       сообщения из данного топика.

    2. Использование семафора в методе consumeMessage:
       В методе consumeMessage используется семафор, чтобы ограничивать количество потребителей, которые могут
       одновременно входить в этот метод:
        ```java
        semaphore.acquire(); // Получаем разрешение на чтение
        ```
       Эта строка блокирует выполнение, если уже maxConsumers потоков получили доступ к этому методу. Если количество
       потребителей, которые уже находятся в этом методе, достигло максимума, поток будет ждать, пока один из них не
       освободит семафор с помощью semaphore.release().

       Освобождение семафора:
       ```java
        semaphore.release(); // Освобождение семафора
       ```
       Это происходит каждый раз, когда поток завершает чтение сообщения из топика, что позволяет другим
       потокам-потребителям получать доступ к методу consumeMessage.

    3. Пример полного механизма:
        - Когда много потребителей пытаются получить сообщение одновременно, для каждого из них вызывается
          consumeMessage.
        - Если текущее количество активных потоков-потребителей меньше maxConsumers, семафор позволяет новому
          потребителю войти в метод.
        - Если же семафор уже занят максимальным количеством потребителей, последующие потребители будут заблокированы
          на semaphore.acquire(), пока один из текущих потребителей не освободит семафор.
        - Таким образом, в любой момент времени только определенное количество потребителей может одновременно читать
          сообщения из топика.